// ==========================================================
// 1. 設定とユーティリティクラス
// ==========================================================

const CONFIG = {
  "MAX_PREDATOR_COUNT": 2, // Unused
  "MAX_FORCE": 0.05,
  "VISUAL_RANGE": 80,
  "AVOID_RADIUS": 20,
  "MAX_TURN_ANGLE": 0.1,
  "BACKGROUND_COLOR": "rgba(0, 0, 10, 1)",
  "PREDATOR_DESPAWN_MARGIN": 100,
  "BOID_SPAWN_MARGIN": 50,
  "PREDATOR_SPAWN_COOLDOWN": 500,
  "OVERPOPULATION_THRESHOLD": 1.05,
  "WHALE_OVERPOPULATION_THRESHOLD": 2,
  "WHALE_SPAWN_COOLDOWN": 7200,
  "PREDATOR_LEAVE_PERCENT": 0.95,
  "PREDATOR_OVERPOPULATION_WEIGHT": 30,
  "PREDATOR_DISTANCE_WEIGHT": 0.1,
  "PREDATOR_NON_TARGET_PENALTY": 20,
  "PLANKTON_SIZE": 1.2,
  "PLANKTON_COLOR": "rgba(255, 255, 255, 0.7)",
  "PLANKTON_WANDER_STRENGTH": 0.08,
  "PLANKTON_GROWTH_RATE": 0.01,
  "FISH_TYPES": {
    "SMALL": {
      "count": 100, "maxSpeed": 1.5, "separationWeight": 2, "alignmentWeight": 1, "cohesionWeight": 1, "width": 16, "height": 8, "turnFactor": 1, "eatRadius": 5, "reproductionCost": 6, "planktonSeekRange": 100
    },
    "MEDIUM": {
      "count": 70, "maxSpeed": 1.5, "separationWeight": 3, "alignmentWeight": 1.5, "cohesionWeight": 1.2, "width": 24, "height": 12, "turnFactor": 0.7, "eatRadius": 8, "reproductionCost": 25, "planktonSeekRange": 100
    },
    "LARGE": {
      "count": 40, "maxSpeed": 1.5, "separationWeight": 3.5, "alignmentWeight": 1.5, "cohesionWeight": 1.2, "width": 32, "height": 16, "turnFactor": 0.7, "eatRadius": 10, "reproductionCost": 30, "planktonSeekMultiplier": 2, "eatCooldown": 600, "planktonSeekRange": 60
    },
    "CUTLASS": {
      "count": 40, "maxSpeed": 1, "separationWeight": 2.5, "alignmentWeight": 0, "cohesionWeight": 0, "width": 30, "height": 5, "turnFactor": 0.8, "eatRadius": 7, "reproductionCost": 50, "eatCooldown": 300, "fleeSpeedMultiplier": 2.2
    },
    "SHARK": {
      "count": 0, "maxSpeed": 3, "separationWeight": 4, "alignmentWeight": 0, "cohesionWeight": 0, "width": 320, "height": 160, "turnFactor": 0.3, "lifespan": 30000, "eatCooldown": 20, "eatDamage": 400, "eats": [ "LARGE", "MEDIUM", "CUTLASS", "SMALL" ], "mouthOffset": 0.4, "eatRadius": 35, "maxCount": 1, "seekRange": 250
    },
    "MARLIN": {
      "count": 0, "maxSpeed": 4, "separationWeight": 4, "alignmentWeight": 0.8, "cohesionWeight": 0.8, "width": 270, "height": 90, "turnFactor": 0.3, "lifespan": 30000, "eatCooldown": 20, "eatDamage": 400, "eats": [ "MEDIUM", "CUTLASS", "SMALL" ], "mouthOffset": 0.35, "eatRadius": 30, "maxCount": 2, "seekRange": 220
    },
    "RAY": {
      "count": 0, "maxSpeed": 2.8, "separationWeight": 4, "alignmentWeight": 0, "cohesionWeight": 0, "width": 150, "height": 120, "turnFactor": 0.4, "lifespan": 30000, "eatCooldown": 30, "eatDamage": 300, "eats": [ "SMALL" ], "mouthOffset": 0.1, "eatRadius": 25, "stealthDuration": 180, "maxCount": 3, "seekRange": 180
    },
    "TUNA": {
      "count": 0, "maxSpeed": 6.75, "separationWeight": 4, "alignmentWeight": 0, "cohesionWeight": 0, "width": 120, "height": 48, "turnFactor": 0.2, "lifespan": 30000, "eatCooldown": 15, "eatDamage": 350, "eats": [ "CUTLASS", "SMALL" ], "mouthOffset": 0.4, "eatRadius": 20, "maxCount": 3, "minSpeedMultiplier": 0.8, "seekRange": 200
    },
    "WHALE": {
      "count": 0, "maxSpeed": 2.5, "separationWeight": 0, "alignmentWeight": 0, "cohesionWeight": 0, "width": 2000, "height": 665, "turnFactor": 0.1, "eats": [ "SMALL", "MEDIUM", "LARGE", "CUTLASS" ], "mouthOffset": { "x": 0.3, "y": 0.05 }, "eatRadius": 150
    }
  }
};

class Vector { constructor(x = 0, y = 0) { this.x = x; this.y = y; } add(v) { return new Vector(this.x + v.x, this.y + v.y); } subtract(v) { return new Vector(this.x - v.x, this.y - v.y); } multiply(scalar) { return new Vector(this.x * scalar, this.y * scalar); } divide(scalar) { return scalar !== 0 ? new Vector(this.x / scalar, this.y / scalar) : new Vector(); } magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); } normalize() { const m = this.magnitude(); return m > 0 ? this.divide(m) : new Vector(); } limit(max) { return this.magnitude() > max ? this.normalize().multiply(max) : this; } dot(v) { return this.x * v.x + this.y * v.y; } angleBetween(v) { const m1 = this.magnitude(); const m2 = v.magnitude(); if (m1 === 0 || m2 === 0) return 0; return Math.acos(Math.max(-1, Math.min(1, this.dot(v) / (m1 * m2)))); } heading() { return Math.atan2(this.y, this.x); } }
class Rectangle { constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; } contains(boid) { return (boid.position.x >= this.x - this.w && boid.position.x <= this.x + this.w && boid.position.y >= this.y - this.h && boid.position.y <= this.y + this.h); } intersects(range) { return !(range.x - range.w > this.x + this.w || range.x + range.w < this.x - this.w || range.y - range.h > this.y + this.h || range.y + range.h < this.y - this.h); } }
class Quadtree { constructor(boundary, capacity) { this.boundary = boundary; this.capacity = capacity; this.boids = []; this.divided = false; } subdivide() { const { x, y, w, h } = this.boundary; const hw = w / 2; const hh = h / 2; this.northwest = new Quadtree(new Rectangle(x - hw, y - hh, hw, hh), this.capacity); this.northeast = new Quadtree(new Rectangle(x + hw, y - hh, hw, hh), this.capacity); this.southwest = new Quadtree(new Rectangle(x - hw, y + hh, hw, hh), this.capacity); this.southeast = new Quadtree(new Rectangle(x + hw, y + hh, hw, hh), this.capacity); this.divided = true; } insert(boid) { if (!this.boundary.contains(boid)) return false; if (this.boids.length < this.capacity) { this.boids.push(boid); return true; } if (!this.divided) this.subdivide(); return (this.northeast.insert(boid) || this.northwest.insert(boid) || this.southeast.insert(boid) || this.southwest.insert(boid)); } query(range, found = []) { if (!this.boundary.intersects(range)) return found; for (const b of this.boids) { if (range.contains(b)) { found.push(b); } } if (this.divided) { this.northwest.query(range, found); this.northeast.query(range, found); this.southwest.query(range, found); this.southeast.query(range, found); } return found; } }

class Boid { constructor(type, image, x = Math.random() * canvas.width, y = Math.random() * canvas.height) { this.type = type; this.config = CONFIG.FISH_TYPES[type] || CONFIG.FISH_TYPES.SMALL; this.position = new Vector(x, y); this.velocity = new Vector((Math.random() - 0.5) * this.config.maxSpeed, (Math.random() - 0.5) * this.config.maxSpeed); this.acceleration = new Vector(); this.image = image; this.alpha = 1; this.isDying = false; this.dyingTimer = 0; this.maxDyingTime = 30; this.isGlowing = false; this.glowingTimer = 0; this.eatCooldownTimer = 0; } startDying() { if (!this.isDying) { this.isDying = true; this.dyingTimer = this.maxDyingTime; } } startGlowing(durationFrames) { this.isGlowing = true; this.glowingTimer = durationFrames; } applyForce(force) { this.acceleration = this.acceleration.add(force); } act(qtree, predators, plankton) { const range = new Rectangle(this.position.x, this.position.y, CONFIG.VISUAL_RANGE, CONFIG.VISUAL_RANGE); const neighbors = qtree.query(range); this.flock(neighbors); this.applyForce(this.flee(predators).multiply(2.5)); } flock(neighbors) { const alignment = this.calculateAlignment(neighbors).multiply(this.config.alignmentWeight); const cohesion = this.calculateCohesion(neighbors).multiply(this.config.cohesionWeight); const separation = this.calculateSeparation(neighbors).multiply(this.config.separationWeight); this.applyForce(alignment); this.applyForce(cohesion); this.applyForce(separation); } update(deltaTime, speedLimit) { if (this.isDying) { this.dyingTimer -= deltaTime; if (this.dyingTimer <= 0) { this.alpha = 0; } return; } if (this.isGlowing) { this.glowingTimer = Math.max(0, this.glowingTimer - deltaTime); if (this.glowingTimer <= 0) { this.isGlowing = false; } } if (this.eatCooldownTimer > 0) { this.eatCooldownTimer = Math.max(0, this.eatCooldownTimer - deltaTime); } const limit = speedLimit !== undefined ? speedLimit : this.config.maxSpeed; this.velocity = this.velocity.add(this.acceleration.multiply(deltaTime)); this.velocity = this.velocity.limit(limit); this.position = this.position.add(this.velocity.multiply(deltaTime)); this.acceleration = new Vector(); this.handleBoundaries(); } handleBoundaries() { if (this.position.x < 0) { this.position.x = 0; this.velocity.x *= -1; } if (this.position.x > canvas.width) { this.position.x = canvas.width; this.velocity.x *= -1; } if (this.position.y < 0) { this.position.y = 0; this.velocity.y *= -1; } if (this.position.y > canvas.height) { this.position.y = canvas.height; this.velocity.y *= -1; } } draw() { ctx.save(); ctx.translate(this.position.x, this.position.y); ctx.rotate(this.velocity.heading() + Math.PI); ctx.globalAlpha = this.alpha * 0.7; if (this.isDying) { if (Math.floor(this.dyingTimer) % 4 < 2) { ctx.restore(); return; } ctx.filter = 'brightness(1.5) drop-shadow(0 0 8px #ff0000)'; const scale = this.dyingTimer / this.maxDyingTime; ctx.scale(scale, scale); } else if (this.isGlowing) { ctx.filter = 'brightness(1.8) drop-shadow(0 0 10px #ffffaa)'; } const w = this.config.width; const h = this.config.height; ctx.drawImage(this.image, -w / 2, -h / 2, w, h); ctx.filter = 'none'; ctx.restore(); } seek(target) { const desired = target.subtract(this.position).normalize().multiply(this.config.maxSpeed); return desired.subtract(this.velocity).limit(CONFIG.MAX_FORCE); } seekClosest(targets) { let closest = null; let minDistance = Infinity; for (const target of targets) { const d = this.position.subtract(target.position).magnitude(); if (d < minDistance) { minDistance = d; closest = target; } } return closest ? this.seek(closest.position) : new Vector(); } flee(threats) { let steer = new Vector(); for (const threat of threats) { if (threat.alpha <= 0 || (threat.type === 'RAY' && threat.isStealthed)) continue; const diff = this.position.subtract(threat.position); const d = diff.magnitude(); if (d < (threat.config.seekRange || 200)) { steer = steer.add(diff.normalize().divide(d)); } } if (steer.magnitude() > 0) { return steer.normalize().multiply(this.config.maxSpeed).subtract(this.velocity).limit(CONFIG.MAX_FORCE * 5); } return steer; } calculateAlignment(neighbors) { let sum = new Vector(); let count = 0; for (const other of neighbors) { if (other !== this && other.type === this.type && other.alpha > 0) { sum = sum.add(other.velocity); count++; } } if (count > 0) { const desired = sum.divide(count).normalize().multiply(this.config.maxSpeed); return desired.subtract(this.velocity).limit(CONFIG.MAX_FORCE); } return new Vector(); } calculateCohesion(neighbors) { let sum = new Vector(); let count = 0; for (const other of neighbors) { if (other !== this && other.type === this.type && other.alpha > 0) { sum = sum.add(other.position); count++; } } if (count > 0) { return this.seek(sum.divide(count)); } return new Vector(); } calculateSeparation(neighbors) { let steer = new Vector(); for (const other of neighbors) { if (other === this || other.alpha <= 0) continue; const d = this.position.subtract(other.position).magnitude(); if (d > 0 && d < CONFIG.AVOID_RADIUS) { const diff = this.position.subtract(other.position).normalize().divide(d); steer = steer.add(diff); } } if (steer.magnitude() > 0) { const desired = steer.normalize().multiply(this.config.maxSpeed); return desired.subtract(this.velocity).limit(CONFIG.MAX_FORCE); } return steer; } }

class Predator extends Boid { constructor(type, image, x, y, vx, vy, targetPreyType) { super(type, image, x, y, vx, vy); this.lifespan = this.config.lifespan; this.isLeaving = false; this.targetPreyType = targetPreyType; } act(qtree, allPrey, currentCounts) { if (this.isLeaving) { const desired = new Vector(canvas.width / 2, canvas.height / 2).subtract(this.position).normalize().multiply(-this.config.maxSpeed); this.applyForce(desired.subtract(this.velocity).limit(CONFIG.MAX_FORCE)); return; } const targetCount = currentCounts[this.targetPreyType] || 0; const initialCount = flock.initialCounts[this.targetPreyType] || 0; if ((targetCount < initialCount * CONFIG.PREDATOR_LEAVE_PERCENT || this.lifespan <= 0) && this.type !== 'WHALE') { this.isLeaving = true; return; } const closestPrey = this.findClosestPrey(allPrey, currentCounts); if (closestPrey && this.canEat()) { const mouthPosition = this.getMouthPosition(); const d = mouthPosition.subtract(closestPrey.position).magnitude(); if (d < this.config.eatRadius && this.velocity.normalize().dot(closestPrey.position.subtract(this.position).normalize()) > 0.6) { closestPrey.startDying(); this.resetEatCooldown(); } else { this.applyForce(this.seek(closestPrey.position)); } } else { const wander = new Vector((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1); this.applyForce(wander); } } getMouthPosition() { if (this.velocity.magnitude() === 0) return this.position; const dir = this.velocity.normalize(); const offsetConf = this.config.mouthOffset; if (typeof offsetConf === 'object' && offsetConf !== null) { const perpendicular = new Vector(dir.y, -dir.x); const offsetX = this.config.width * offsetConf.x; const offsetY = this.config.height * offsetConf.y; return this.position.add(dir.multiply(offsetX)).add(perpendicular.multiply(offsetY)); } else { return this.position.add(dir.multiply(this.config.width * offsetConf)); } } findClosestPrey(preyList, currentCounts) { const availablePrey = preyList.filter(p => p.alpha > 0 && !p.isDying && this.config.eats.includes(p.type)); if (availablePrey.length === 0) return null; let bestTarget = null; let maxScore = -Infinity; for (const prey of availablePrey) { const d = this.position.subtract(prey.position).magnitude(); if (d < this.config.seekRange) { const abundance = currentCounts[prey.type] || 0; const overpopulationRatio = Math.max(0, (abundance / (flock.initialCounts[prey.type] || 1)) - 1.0); const score = (overpopulationRatio * CONFIG.PREDATOR_OVERPOPULATION_WEIGHT) - (d * CONFIG.PREDATOR_DISTANCE_WEIGHT) - (prey.type !== this.targetPreyType ? CONFIG.PREDATOR_NON_TARGET_PENALTY : 0); if (score > maxScore) { maxScore = score; bestTarget = prey; } } } return bestTarget; } update(deltaTime) { if (this.alpha <= 0) return; if (this.lifespan > 0) this.lifespan--; super.update(deltaTime); } handleBoundaries() { const margin = CONFIG.PREDATOR_DESPAWN_MARGIN; if (this.isLeaving) { if (this.position.x < -margin || this.position.x > canvas.width + margin || this.position.y < -margin || this.position.y > canvas.height + margin) { this.alpha = 0; } } else { if (this.position.x < -margin) this.position.x = canvas.width + margin; if (this.position.x > canvas.width + margin) this.position.x = -margin; if (this.position.y < -margin) this.position.y = canvas.height + margin; if (this.position.y > canvas.height + margin) this.position.y = -margin; } } canEat() { return this.eatCooldownTimer === 0; } resetEatCooldown() { this.eatCooldownTimer = this.config.eatCooldown; this.lifespan -= this.config.eatDamage; } }

class Shark extends Predator { constructor(image, x, y, vx, vy, targetPreyType) { super('SHARK', image, x, y, vx, vy, targetPreyType); } }
class Marlin extends Predator { constructor(image, x, y, vx, vy, targetPreyType) { super('MARLIN', image, x, y, vx, vy, targetPreyType); } act(qtree, allPrey, currentCounts) { const neighbors = qtree.query(new Rectangle(this.position.x, this.position.y, CONFIG.VISUAL_RANGE, CONFIG.VISUAL_RANGE)); this.flock(neighbors); super.act(qtree, allPrey, currentCounts); } }
class Ray extends Predator { constructor(image, x, y, vx, vy, targetPreyType) { super('RAY', image, x, y, vx, vy, targetPreyType); this.idleTimer = 0; this.isStealthed = false; } act(qtree, allPrey, currentCounts) { if (this.velocity.magnitude() < 0.1) { this.idleTimer++; } else { this.idleTimer = 0; this.isStealthed = false; } if (this.idleTimer >= this.config.stealthDuration) { this.isStealthed = true; } if (this.isStealthed) { this.acceleration = new Vector(); const closestPrey = this.findClosestPrey(allPrey, currentCounts); if (closestPrey) { this.applyForce(this.seek(closestPrey.position).multiply(2.0)); } } else { super.act(qtree, allPrey, currentCounts); } } draw() { ctx.save(); ctx.translate(this.position.x, this.position.y); ctx.rotate(this.velocity.heading() + Math.PI); const baseAlpha = this.isStealthed ? 0.3 : 0.7; ctx.globalAlpha = this.alpha * baseAlpha; if (this.isDying) { if (Math.floor(this.dyingTimer) % 4 < 2) { ctx.restore(); return; } ctx.filter = 'brightness(1.5) drop-shadow(0 0 8px #ff0000)'; const scale = this.dyingTimer / this.maxDyingTime; ctx.scale(scale, scale); } else if (this.isGlowing) { ctx.filter = 'brightness(1.8) drop-shadow(0 0 10px #ffffaa)'; } const w = this.config.width; const h = this.config.height; ctx.drawImage(this.image, -w / 2, -h / 2, w, h); ctx.filter = 'none'; ctx.restore(); } }
class Tuna extends Predator { constructor(image, x, y, vx, vy, targetPreyType) { super('TUNA', image, x, y, vx, vy, targetPreyType); } act(qtree, allPrey, currentCounts) { super.act(qtree, allPrey, currentCounts); if (this.velocity.magnitude() < this.config.maxSpeed * (this.config.minSpeedMultiplier || 0.8)) { this.applyForce(this.velocity.normalize().multiply(0.2)); } } }
class SolitaryBoid extends Boid { constructor(image, x, y) { super('CUTLASS', image, x, y); this.isFleeing = false; } act(qtree, predators, plankton) { const fleeForce = this.flee(predators).multiply(3.0); this.isFleeing = fleeForce.magnitude() > 0; const wander = new Vector((Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1); const range = new Rectangle(this.position.x, this.position.y, CONFIG.AVOID_RADIUS, CONFIG.AVOID_RADIUS); const neighbors = qtree.query(range); const separationForce = this.calculateSeparation(neighbors).multiply(this.config.separationWeight); this.applyForce(fleeForce); this.applyForce(wander); this.applyForce(separationForce); if (this.eatCooldownTimer === 0) { const foodAttraction = this.seekClosest(plankton, CONFIG.VISUAL_RANGE).multiply(2.0); this.applyForce(foodAttraction); } } update(deltaTime) { const speedLimit = this.isFleeing ? this.config.maxSpeed * this.config.fleeSpeedMultiplier : this.config.maxSpeed; super.update(deltaTime, speedLimit); } }
class Plankton { constructor(x = Math.random() * canvas.width, y = Math.random() * canvas.height) { this.position = new Vector(x, y); this.size = 0; this.maxSize = CONFIG.PLANKTON_SIZE; this.wanderAngle = Math.random() * Math.PI * 2; } update(deltaTime) { if (this.size < this.maxSize) this.size += CONFIG.PLANKTON_GROWTH_RATE; this.wanderAngle += (Math.random() - 0.5) * CONFIG.PLANKTON_WANDER_STRENGTH; this.position.x += Math.cos(this.wanderAngle) * 0.1; this.position.y += Math.sin(this.wanderAngle) * 0.1; if (this.position.x < 0) this.position.x = 0; if (this.position.x > canvas.width) this.position.x = canvas.width; if (this.position.y < 0) this.position.y = 0; if (this.position.y > canvas.height) this.position.y = canvas.height; } draw() { ctx.fillStyle = CONFIG.PLANKTON_COLOR; ctx.beginPath(); ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2); ctx.fill(); } }
class Whale extends Predator { constructor(image, x, y, vx, vy) { super('WHALE', image, x, y, vx, vy); } act(qtree, allPrey) { const mouthPosition = this.getMouthPosition(); for (const prey of allPrey) { if (prey.alpha > 0 && !prey.isDying) { const d = mouthPosition.subtract(prey.position).magnitude(); if (d < this.config.eatRadius) { prey.startDying(); } } } } handleBoundaries() { const margin = this.config.width; if (this.velocity.x > 0 && this.position.x > canvas.width + margin) { this.alpha = 0; } if (this.velocity.x < 0 && this.position.x < -margin) { this.alpha = 0; } } }
class SpawnEffect { constructor(position) { this.position = position; this.maxLifespan = 40; this.lifespan = this.maxLifespan; this.initialRadius = 60; } update(deltaTime) { this.lifespan -= deltaTime; } draw() { const progress = this.lifespan / this.maxLifespan; if (progress < 0) return; const currentRadius = this.initialRadius * (1 - progress); const alpha = progress; ctx.beginPath(); const gradient = ctx.createRadialGradient(this.position.x, this.position.y, currentRadius * 0.5, this.position.x, this.position.y, currentRadius); gradient.addColorStop(0, `rgba(150, 200, 255, ${alpha * 0.5})`); gradient.addColorStop(1, `rgba(150, 200, 255, 0)`); ctx.fillStyle = gradient; ctx.arc(this.position.x, this.position.y, currentRadius, 0, Math.PI * 2); ctx.fill(); } }

class Flock {
    constructor(images) { this.boids = []; this.predators = []; this.solitary = []; this.plankton = []; this.spawnEffects = []; this.qtree = null; this.predatorSpawnCooldownTimer = 0; this.whaleSpawnCooldownTimer = 0; this.initialCounts = {}; this.images = images; this.reproductionProgress = {}; this.currentCounts = {}; this.init(); }
    init() { for (const type in CONFIG.FISH_TYPES) { if (CONFIG.FISH_TYPES[type].count > 0) { this.initialCounts[type] = CONFIG.FISH_TYPES[type].count; for (let i = 0; i < CONFIG.FISH_TYPES[type].count; i++) { const image = this.images[type]; if (type === 'CUTLASS') { this.solitary.push(new SolitaryBoid(image)); } else { this.boids.push(new Boid(type, image)); } } } } for (const type in this.initialCounts) { this.reproductionProgress[type] = 0; } for (let i = 0; i < (CONFIG.PLANKTON_COUNT || 50); i++) { this.plankton.push(new Plankton()); } }
    update(deltaTime) { this.updateCurrentCounts(); const allPrey = [...this.boids, ...this.solitary]; const boundary = new Rectangle(canvas.width / 2, canvas.height / 2, canvas.width / 2, canvas.height / 2); this.qtree = new Quadtree(boundary, 4); const allBoids = [...allPrey, ...this.predators]; for(const boid of allBoids) { if(boid.alpha > 0) this.qtree.insert(boid); } for (const boid of this.boids) { if (boid.alpha > 0) { boid.act(this.qtree, this.predators, this.plankton); boid.update(deltaTime); this.eatPlankton(boid); } } for (const s of this.solitary) { if (s.alpha > 0) { s.act(this.qtree, this.predators, this.plankton); s.update(deltaTime); this.eatPlankton(s); } } for (const p of this.predators) { if (p.alpha > 0) { p.act(this.qtree, allPrey, this.currentCounts); p.update(deltaTime); } } for (const p of this.plankton) { p.update(deltaTime); } this.spawnEffects.forEach(e => e.update(deltaTime)); this.cleanupAndRespawn(); }
    updateCurrentCounts() { this.currentCounts = {}; [...this.boids, ...this.solitary].forEach(p => { if(p.alpha > 0 && !p.isDying) this.currentCounts[p.type] = (this.currentCounts[p.type] || 0) + 1; }); }
    draw() { ctx.shadowBlur = 4; for (const p of this.plankton) p.draw(); ctx.shadowBlur = 0; for (const effect of this.spawnEffects) { effect.draw(); } for (const s of this.solitary) if (s.alpha > 0) s.draw(); for (const b of this.boids) if (b.alpha > 0) b.draw(); for (const p of this.predators) if (p.alpha > 0) p.draw(); this.drawPopulationCount(); }
    drawPopulationCount() { const preyTypes = ['LARGE', 'MEDIUM', 'CUTLASS', 'SMALL']; ctx.font = '12px Arial'; ctx.fillStyle = 'rgba(50, 100, 150, 0.9)'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; let yPos = canvas.height - 10; const lineHeight = 15; for (const type of preyTypes) { const config = CONFIG.FISH_TYPES[type]; const count = this.currentCounts[type] || 0; const initial = this.initialCounts[type] || 0; const popPercent = initial > 0 ? Math.floor((count/initial)*100) : 0; const progress = this.reproductionProgress[type] || 0; const cost = config.reproductionCost; const reproPercent = cost > 0 ? Math.floor((progress / cost) * 100) : 0; const text = `${type.padEnd(7)}: ${String(count).padStart(3)} (Init: ${initial}, Pop:${popPercent}%) | Repro: ${progress}/${cost} (${reproPercent}%)`; ctx.fillText(text, 15, yPos); yPos -= lineHeight; } }
    eatPlankton(boid) { if (boid.eatCooldownTimer > 0) return; for (let i = this.plankton.length - 1; i >= 0; i--) { const p = this.plankton[i]; if (p && boid.position.subtract(p.position).magnitude() < boid.config.eatRadius) { this.plankton.splice(i, 1); this.plankton.push(new Plankton()); if (boid.config.eatCooldown) boid.eatCooldownTimer = boid.config.eatCooldown; if (this.reproductionProgress[boid.type] !== undefined) { this.reproductionProgress[boid.type]++; } if (boid.config.reproductionCost && this.reproductionProgress[boid.type] >= boid.config.reproductionCost) { this.respawnBoid(boid.type); this.reproductionProgress[boid.type] -= boid.config.reproductionCost; } return; } } }
    cleanupAndRespawn() { this.boids = this.boids.filter(b => b.alpha > 0); this.solitary = this.solitary.filter(s => s.alpha > 0); this.predators = this.predators.filter(p => p.alpha > 0); this.spawnEffects = this.spawnEffects.filter(e => e.lifespan > 0); this.predatorSpawnCooldownTimer = Math.max(0, this.predatorSpawnCooldownTimer - 1); this.whaleSpawnCooldownTimer = Math.max(0, this.whaleSpawnCooldownTimer - 1); this.checkAndSpawnPredators(); }
    checkAndSpawnPredators() { let overpopulatedType105 = null; let overpopulatedType200 = null; for(const type in this.initialCounts) { const currentCount = this.currentCounts[type] || 0; const initialCount = this.initialCounts[type]; if (currentCount > initialCount * CONFIG.WHALE_OVERPOPULATION_THRESHOLD) { overpopulatedType200 = type; } if (currentCount > initialCount * CONFIG.OVERPOPULATION_THRESHOLD) { overpopulatedType105 = type; } } if (overpopulatedType200 && this.whaleSpawnCooldownTimer === 0) { this.spawnWhale(); this.whaleSpawnCooldownTimer = CONFIG.WHALE_SPAWN_COOLDOWN; return; } if (overpopulatedType105 && this.predatorSpawnCooldownTimer === 0) { this.spawnRegularPredator(overpopulatedType105); } }
    spawnRegularPredator(overpopulatedType) { const predatorMap = { LARGE: 'SHARK', MEDIUM: 'MARLIN', CUTLASS: 'TUNA', SMALL: 'RAY' }; const predatorTypeToSpawn = predatorMap[overpopulatedType]; if (!predatorTypeToSpawn) return; const currentPredatorCount = this.predators.filter(p => p.type === predatorTypeToSpawn).length; const maxPredatorCount = CONFIG.FISH_TYPES[predatorTypeToSpawn].maxCount; if (currentPredatorCount >= maxPredatorCount) return; const side = Math.floor(Math.random() * 4); let x, y, vx, vy; const margin = CONFIG.PREDATOR_DESPAWN_MARGIN; const speed = CONFIG.FISH_TYPES[predatorTypeToSpawn].maxSpeed; switch (side) { case 0: x = Math.random() * canvas.width; y = -margin; vx = (Math.random() - 0.5) * speed; vy = Math.random() * speed / 2 + speed / 2; break; case 1: x = canvas.width + margin; y = Math.random() * canvas.height; vx = -(Math.random() * speed / 2 + speed / 2); vy = (Math.random() - 0.5) * speed; break; case 2: x = Math.random() * canvas.width; y = canvas.height + margin; vx = (Math.random() - 0.5) * speed; vy = -(Math.random() * speed / 2 + speed / 2); break; case 3: x = -margin; y = Math.random() * canvas.height; vx = Math.random() * speed / 2 + speed / 2; vy = (Math.random() - 0.5) * speed; break; } const image = this.images[predatorTypeToSpawn]; switch(predatorTypeToSpawn) { case 'SHARK': this.predators.push(new Shark(image, x, y, vx, vy, overpopulatedType)); break; case 'MARLIN': this.predators.push(new Marlin(image, x, y, vx, vy, overpopulatedType)); break; case 'RAY': this.predators.push(new Ray(image, x, y, vx, vy, overpopulatedType)); break; case 'TUNA': this.predators.push(new Tuna(image, x, y, vx, vy, overpopulatedType)); break; } this.predatorSpawnCooldownTimer = CONFIG.PREDATOR_SPAWN_COOLDOWN; }
    respawnBoid(type) { const margin = CONFIG.BOID_SPAWN_MARGIN; const side = Math.floor(Math.random() * 4); let x, y; if (side === 0) { x = Math.random() * canvas.width; y = -margin; } else if (side === 1) { x = canvas.width + margin; y = Math.random() * canvas.height; } else if (side === 2) { x = Math.random() * canvas.width; y = canvas.height + margin; } else { x = -margin; y = Math.random() * canvas.height; } const image = this.images[type]; let newBoid; if (type === 'CUTLASS') { newBoid = new SolitaryBoid(image, x, y); this.solitary.push(newBoid); } else { newBoid = new Boid(type, image, x, y); this.boids.push(newBoid); } const center = new Vector(canvas.width / 2, canvas.height / 2); const dirToCenter = center.subtract(newBoid.position).normalize(); newBoid.velocity = dirToCenter.multiply(newBoid.config.maxSpeed); newBoid.startGlowing(180); const effectPos = new Vector(Math.max(0, Math.min(canvas.width, x)), Math.max(0, Math.min(canvas.height, y))); const color = CONFIG.FISH_TYPES[type].spawnColor || "150, 200, 255"; this.spawnEffects.push(new SpawnEffect(effectPos, color)); }
    spawnWhale() { const image = this.images.WHALE; const config = CONFIG.FISH_TYPES.WHALE; const margin = config.width / 2; let x, y, vx, vy; y = Math.random() * (canvas.height * 0.6) + (canvas.height * 0.2); vy = 0; if (Math.random() < 0.5) { x = -margin; vx = config.maxSpeed; } else { x = canvas.width + margin; vx = -config.maxSpeed; } this.predators.push(new Whale(image, x, y, vx, vy)); }
}

const canvas = document.getElementById('boidsCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let flock;
let lastTime = 0;
let animationId;
let loadedImages;

function animate(currentTime) { if (lastTime === 0) { lastTime = currentTime; } const deltaTime = (currentTime - lastTime) / 16.67; lastTime = currentTime; ctx.fillStyle = CONFIG.BACKGROUND_COLOR; ctx.fillRect(0, 0, canvas.width, canvas.height); flock.update(deltaTime); flock.draw(); animationId = requestAnimationFrame(animate); }

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

// ===== UI & CONTROL LOGIC =====
function populateUI() { /* ... unchanged ... */ }
function updateConfigFromUI() { /* ... unchanged ... */ }
function resetSimulation() { cancelAnimationFrame(animationId); lastTime = 0; updateConfigFromUI(); flock = new Flock(loadedImages); animate(performance.now()); }
function handleCopyConfig() { updateConfigFromUI(); const configString = `const CONFIG = ${JSON.stringify(CONFIG, null, 2)};`; navigator.clipboard.writeText(configString).then(() => { const btn = document.getElementById('copyBtn'); btn.textContent = 'Copied!'; setTimeout(() => { btn.textContent = 'Copy Config'; }, 2000); }).catch(err => console.error('Failed to copy config: ', err)); }

function toggleControls() {
    const controls = document.getElementById('controls');
    controls.classList.toggle('visible');
}

document.querySelectorAll('.collapsible-header').forEach(header => {
    header.addEventListener('click', () => {
        const content = header.nextElementSibling;
        content.classList.toggle('expanded');
    });
});

document.getElementById('applyBtn').addEventListener('click', resetSimulation);
document.getElementById('copyBtn').addEventListener('click', handleCopyConfig);
document.getElementById('control-header').addEventListener('click', (e) => { if (e.target.id !== 'toggle-btn') toggleControls(); });
document.getElementById('toggle-btn').addEventListener('click', toggleControls);

window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'd') {
        const controls = document.getElementById('controls');
        if (document.activeElement.tagName.toLowerCase() !== 'input') {
            controls.classList.toggle('visible');
        }
    }
});

console.log("Loading assets...");
loadAssets().then(images => {
    console.log("Assets loaded successfully!");
    loadedImages = images;
    flock = new Flock(loadedImages);
    populateUI();
    animationId = requestAnimationFrame(animate);
}).catch(error => { console.error("Could not initialize simulation:", error); });