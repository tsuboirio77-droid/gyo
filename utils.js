// FILE: utils.js
class Vector { constructor(x = 0, y = 0) { this.x = x; this.y = y; } add(v) { return new Vector(this.x + v.x, this.y + v.y); } subtract(v) { return new Vector(this.x - v.x, this.y - v.y); } multiply(scalar) { return new Vector(this.x * scalar, this.y * scalar); } divide(scalar) { return scalar !== 0 ? new Vector(this.x / scalar, this.y / scalar) : new Vector(); } magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); } normalize() { const m = this.magnitude(); return m > 0 ? this.divide(m) : new Vector(); } limit(max) { return this.magnitude() > max ? this.normalize().multiply(max) : this; } dot(v) { return this.x * v.x + this.y * v.y; } angleBetween(v) { const m1 = this.magnitude(); const m2 = v.magnitude(); if (m1 === 0 || m2 === 0) return 0; return Math.acos(Math.max(-1, Math.min(1, this.dot(v) / (m1 * m2)))); } heading() { return Math.atan2(this.y, this.x); } rotate(angle) { const cos = Math.cos(angle); const sin = Math.sin(angle); return new Vector(this.x * cos - this.y * sin, this.x * sin + this.y * cos); } }
class Rectangle { constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; } contains(point) { return (point.position.x >= this.x - this.w && point.position.x <= this.x + this.w && point.position.y >= this.y - this.h && point.position.y <= this.y + this.h); } intersects(range) { return !(range.x - range.w > this.x + this.w || range.x + range.w < this.x - this.w || range.y - range.h > this.y + this.h || range.y + range.h < this.y - this.h); } }
class Quadtree { constructor(boundary, capacity) { this.boundary = boundary; this.capacity = capacity; this.points = []; this.divided = false; } subdivide() { const { x, y, w, h } = this.boundary; const hw = w / 2; const hh = h / 2; this.northwest = new Quadtree(new Rectangle(x - hw, y - hh, hw, hh), this.capacity); this.northeast = new Quadtree(new Rectangle(x + hw, y - hh, hw, hh), this.capacity); this.southwest = new Quadtree(new Rectangle(x - hw, y + hh, hw, hh), this.capacity); this.southeast = new Quadtree(new Rectangle(x + hw, y + hh, hw, hh), this.capacity); this.divided = true; } insert(point) { if (!this.boundary.contains(point)) return false; if (this.points.length < this.capacity) { this.points.push(point); return true; } if (!this.divided) this.subdivide(); return (this.northeast.insert(point) || this.northwest.insert(point) || this.southeast.insert(point) || this.southwest.insert(point)); } query(range, found = []) { if (!this.boundary.intersects(range)) return found; for (const p of this.points) { if (range.contains(p)) { found.push(p); } } if (this.divided) { this.northwest.query(range, found); this.northeast.query(range, found); this.southwest.query(range, found); this.southeast.query(range, found); } return found; } }